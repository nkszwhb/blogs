(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{602:function(t,e,a){"use strict";a.r(e);var s=a(9),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"react-native-之列表性能配置优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-native-之列表性能配置优化"}},[t._v("#")]),t._v(" react-native 之列表性能配置优化")]),t._v(" "),a("h3",{attrs:{id:"props"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#props"}},[t._v("#")]),t._v(" Props")]),t._v(" "),a("p",[t._v("以下是一些能够帮助你提高FlatList表现的属性:")]),t._v(" "),a("h4",{attrs:{id:"initialnumtorender"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#initialnumtorender"}},[t._v("#")]),t._v(" "),a("code",[t._v("initialNumToRender")])]),t._v(" "),a("p",[t._v("首批应该渲染的元素数量。这些元素应该能够覆盖住屏幕，但再多就不好了。注意：为了响应“滚动到顶部”这个事件并最优化其性能，这些元素将作为窗口渲染的一部分，永远不会被卸载。")]),t._v(" "),a("h4",{attrs:{id:"maxtorenderperbatch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#maxtorenderperbatch"}},[t._v("#")]),t._v(" "),a("code",[t._v("maxToRenderPerBatch")])]),t._v(" "),a("p",[t._v("每批增量渲染可渲染的最大数量。能立即渲染出的元素数量越多，填充速率就越快，但是响应性可能会有一些损失，因为每个被渲染的元素都可能参与或干扰对按钮点击事件或其他事件的响应。")]),t._v(" "),a("h4",{attrs:{id:"removeclippedsubviews"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#removeclippedsubviews"}},[t._v("#")]),t._v(" "),a("code",[t._v("removeClippedSubviews")])]),t._v(" "),a("p",[t._v("一个将“剪裁子视图”(clipped subviews)（指的是那些在父视图之外的视图）从视图层级中删除的本地优化，为的是减轻渲染系统的工作负担。但是这些被剪裁掉的子视图依然保留在内存中，所以它们所占的储存空间没有被释放，内部状态也都保留了下来。")]),t._v(" "),a("p",[a("strong",[t._v("好处：")]),t._v(" 启用此选项可减少花在主线程上的时间，从而降低丢帧的风险。原理是对视口之外的视图不进行本地渲染和绘图遍历。")]),t._v(" "),a("p",[a("strong",[t._v("坏处：")]),t._v(" 请注意，这种实现可能会有 bug，比如丢失内容（主要是在 iOS 上观察到的），特别是当你使用变换和/或绝对定位做复杂的事情时。另外，请注意这并不会节省大量的内存，因为视图并没有被销毁，只是被分离了。")]),t._v(" "),a("h4",{attrs:{id:"windowsize"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#windowsize"}},[t._v("#")]),t._v(" "),a("code",[t._v("windowSize")])]),t._v(" "),a("p",[t._v("设置可视区外最大能被渲染的元素的数量，以可视区的长度为单位。比如说，如果列表占满了整个屏幕，而 windowSize 属性被设置为 21 的话，那渲染的长度为包括当前可见屏幕区域在内，往上 10 个屏幕的长度和往下 10 个屏幕的长度。将 windowSize 设置为一个较小值，能有减小内存消耗并提高性能，但是当你快速滚动列表时，遇到尚未渲染的内容的几率会增大，而这些尚未渲染的内容会暂时性地被空白区块所替代。")]),t._v(" "),a("h4",{attrs:{id:"maxtorenderperbatch-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#maxtorenderperbatch-2"}},[t._v("#")]),t._v(" "),a("code",[t._v("maxToRenderPerBatch")])]),t._v(" "),a("p",[t._v("每批增量渲染可渲染的最大数量。能立即渲染出的元素数量越多，填充速率就越快，但是响应性可能会有一些损失，因为每个被渲染的元素都可能参与或干扰对按钮点击事件或其他事件的响应。")]),t._v(" "),a("p",[a("strong",[t._v("好处：")]),t._v(" 设置更大的数字意味着滚动时视觉空白区域更少(增加填充率)。")]),t._v(" "),a("p",[a("strong",[t._v("坏处：")]),t._v(" 每批处理的项目越多，意味着JavaScript执行的时间越长，可能会阻塞其他事件处理，比如按下按钮，从而影响响应能力。")]),t._v(" "),a("h4",{attrs:{id:"updatecellsbatchingperiod"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#updatecellsbatchingperiod"}},[t._v("#")]),t._v(" "),a("code",[t._v("updateCellsBatchingPeriod")])]),t._v(" "),a("p",[t._v("具有较低渲染优先级的元素（比如那些离屏幕相当远的元素）的渲染批次之间的时间间隔。与 maxToRenderPerBatch 具有相同的目的，都是为了在渲染速率和响应性之间获得一个平衡。")]),t._v(" "),a("p",[t._v("maxToRenderPerBatch告诉每批渲染的项目数量，设置updateCellsBatchingPeriod告诉VirtualizedList批渲染之间的延迟(以毫秒为单位)(你的组件渲染窗口项目的频率)。")]),t._v(" "),a("p",[a("strong",[t._v("好处：")]),t._v(" 将这个属性与maxToRenderPerBatch相结合，可以让你你的列表有更好的性能表现，例如，在一个不太频繁的批处理中呈现更多的项目，或者在一个更频繁的批处理中呈现更少的项目。")]),t._v(" "),a("p",[a("strong",[t._v("坏处：")]),t._v(" 较不频繁的批次可能会导致空白区域，较频繁的批次可能会导致响应性问题。")]),t._v(" "),a("h4",{attrs:{id:"getitemlayout"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#getitemlayout"}},[t._v("#")]),t._v(" "),a("code",[t._v("getItemLayout")])]),t._v(" "),a("p",[t._v("getItemLayout 是一个可选的优化，用于避免动态测量内容尺寸的开销，不过前提是你可以提前知道内容的高度。如果你的行高是固定的，getItemLayout 用起来就既高效又简单。如果行高不固定，这里也是有办法来实现该方法来优化的。具体在本节后面回讲到。")]),t._v(" "),a("p",[t._v("以上几个属性都能优化列表的属性。")]),t._v(" "),a("h3",{attrs:{id:"list-items"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#list-items"}},[t._v("#")]),t._v(" List items")]),t._v(" "),a("p",[t._v("下面是一些关于列表项组件的提示。它们是列表的核心，所以它们需要能够快速响应。")]),t._v(" "),a("h4",{attrs:{id:"使用简单组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用简单组件"}},[t._v("#")]),t._v(" 使用简单组件")]),t._v(" "),a("p",[t._v("组件越复杂一般渲染就越慢。尽量避免列表项中有很多逻辑和嵌套。如果你在你的应用中经常重用这个列表项组件，为你的大列表创建一个组件，让它们尽可能少的逻辑和嵌套。")]),t._v(" "),a("h4",{attrs:{id:"使用轻量组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用轻量组件"}},[t._v("#")]),t._v(" 使用轻量组件")]),t._v(" "),a("p",[t._v("组件太重自然也会拖慢渲染。尽量避免使用大图片（优先使用裁剪过的版本或是缩略图，总之越小越好）。和负责设计的同事协商，在列表中尽可能简化特效和交互，精简要展示的信息，把长内容移到详情页中。")]),t._v(" "),a("h4",{attrs:{id:"使用-shouldcomponentupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-shouldcomponentupdate"}},[t._v("#")]),t._v(" 使用 shouldComponentUpdate")]),t._v(" "),a("h4",{attrs:{id:"使用优化缓存的图片库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用优化缓存的图片库"}},[t._v("#")]),t._v(" 使用优化缓存的图片库")]),t._v(" "),a("p",[t._v("您可以使用社区包（例如as "),a("a",{attrs:{href:"https://github.com/DylanVann/react-native-fast-image",target:"_blank",rel:"noopener noreferrer"}},[t._v("react-native-fast-image"),a("OutboundLink")],1),t._v("）来获得更多性能图片。列表中的每个图像都是一个 "),a("code",[t._v("new imagee()")]),t._v("的实例。它到达加载的钩子的速度越快，你的Javascript线程就会越快地恢复空闲状态。")]),t._v(" "),a("h4",{attrs:{id:"使用-keyextractor-或-key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-keyextractor-或-key"}},[t._v("#")]),t._v(" 使用 keyExtractor 或 key")]),t._v(" "),a("p",[t._v("你可以为FlatList组件设置 "),a("code",[t._v("keyExtractor")]),t._v("属性。此属性用于缓存和作为React key 来跟踪物品重新排序。")]),t._v(" "),a("p",[t._v("你也可以在item组件中设置"),a("code",[t._v("key")]),t._v("属性。")]),t._v(" "),a("h3",{attrs:{id:"避免在-renderitem-中使用匿名函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#避免在-renderitem-中使用匿名函数"}},[t._v("#")]),t._v(" 避免在 renderItem 中使用匿名函数")]),t._v(" "),a("p",[t._v("将"),a("code",[t._v("renderItem")]),t._v("函数移出到渲染函数的外部，所以它不会在每次调用渲染函数时重新创建自己。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("renderItem")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" item "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("View key"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("item"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Text"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("item"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("title"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("Text"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("View"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("FlatList data"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("items"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" renderItem"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("renderItem"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("h4",{attrs:{id:"使用-getitemlayout"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-getitemlayout"}},[t._v("#")]),t._v(" 使用 getItemLayout")]),t._v(" "),a("blockquote",[a("p",[t._v("此属性关系到 FlatList 的 "),a("code",[t._v("initialScrollIndex")]),t._v(" "),a("code",[t._v("scrollToIndex")]),t._v(" "),a("code",[t._v("scrollToItem")]),t._v(" 和 "),a("code",[t._v("SectionList")]),t._v("的"),a("code",[t._v("scrollToLocation")]),t._v("方法的使用。")])]),t._v(" "),a("p",[t._v("如果你所有的列表项组件都有相同的高度(或者宽度，对于水平列表来说)，提供getItemLayout道具可以让你的FlatList不再需要管理异步布局计算。这是一种非常理想的优化技术。")]),t._v(" "),a("p",[t._v("如果组件的大小是动态的，同样也有方法将使用该属性进行优化。")]),t._v(" "),a("ol",[a("li",[t._v("getItemLayout 使用分析")])]),t._v(" "),a("p",[t._v("以下是"),a("code",[t._v("FlatList")]),t._v("和"),a("code",[t._v("SectionList")]),t._v("的属性接口")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// FlatList")]),t._v("\ngetItemLayout"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("data"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    index"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    length"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    offset"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    index"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// SectionList")]),t._v("\n getItemLayout"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n     "),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("data"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" SectionListData"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("ItemT"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n     index"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")])]),t._v("\n "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" length"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" offset"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" index"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("该方法要求返回 "),a("code",[t._v("offset")]),t._v(" "),a("code",[t._v("length")]),t._v(" "),a("code",[t._v("index")]),t._v("三个值，")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("index")]),t._v("始于"),a("code",[t._v("ListHeaderComponent")]),t._v("也就是说"),a("code",[t._v("ListHeaderComponent")]),t._v("组件的"),a("code",[t._v("index")]),t._v("是0， 在"),a("code",[t._v("sectionList")]),t._v("中第一个"),a("code",[t._v("section")]),t._v("的"),a("code",[t._v("header")]),t._v("的"),a("code",[t._v("index")]),t._v("是1，对于"),a("code",[t._v("FlatList")]),t._v("没有"),a("code",[t._v("renderSectionHeader")]),t._v("，那么它的第一个"),a("code",[t._v("item")]),t._v("的inde就是1，从"),a("code",[t._v("ListHeaderComponent")]),t._v(" 到 "),a("code",[t._v("ListFooterComponent")]),t._v(" 依次+1")]),t._v(" "),a("li",[a("code",[t._v("length")]),t._v(" 所需要返回的就是当前item的的高度")]),t._v(" "),a("li",[a("code",[t._v("offset")]),t._v(" 的值是当前 "),a("code",[t._v("item")]),t._v(" 前面 所有"),a("code",[t._v("item")]),t._v("的高度 + 所有"),a("code",[t._v("sectionHeader")]),t._v("的高度 + 所有"),a("code",[t._v("sectionFooter")]),t._v("的高度 + "),a("code",[t._v("ListHeaderComponent")]),t._v(" 的高度 + 当前"),a("code",[t._v("item")]),t._v("的高度")])]),t._v(" "),a("p",[t._v("此属性在会在渲染和复用 "),a("code",[t._v("item")]),t._v(" 的时候计算以定位组件的位置。对于 item 高度是固定的使用起来方便，对于组件大小是动态的就必须提前知道 item 的行高了。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("获取 item 的高度。")])]),t._v(" "),a("p",[t._v("以下是我在开发中使用的方法。实际场景是门锁插件中有一个日志列表。如下图：")]),t._v(" "),a("img",{staticStyle:{zoom:"33%"},attrs:{src:"http://hoh.synology.me:6677/i/2022/06/11/982bdc194d3fd6647e0a83beb96c3268/62a43844be3c3.png",alt:"IMG_5394"}}),t._v(" "),a("p",[t._v("对于动态组件的高度，可以将动态部分单独抽出来使用一个 "),a("code",[t._v("FlatList")]),t._v(" 去渲染，如果你的动态部分每一个组件的高度都不同的话，对不起，我也没有办法。在这个日志列表中，其中动态部分就是 "),a("code",[t._v("item")]),t._v(" 中的日志文案了，并且在英文状态下，不同设备上是完全没发确认高度的，为此，我将 "),a("code",[t._v("redux")]),t._v(" 中的数据单独抽离了一份文案，并且这份文案都是不重复的。我在整个 "),a("code",[t._v("App")]),t._v(" 插件下方隐藏了一个 "),a("code",[t._v("FlatList")]),t._v(" 只渲染 "),a("code",[t._v("Text")]),t._v(" 部分。并且将 "),a("code",[t._v("text")]),t._v(" 的使用 "),a("code",[t._v("onLayout")]),t._v(" 计算出了Item的行数，并将行数记录了在一个 "),a("code",[t._v("map")]),t._v(" 中，如果 "),a("code",[t._v("map")]),t._v(" 中有该数据，"),a("code",[t._v("FlatList")]),t._v(" 无需再次渲染计算。有了行数在 "),a("code",[t._v("getItemLayout")]),t._v(" 就可以计算每个日志 "),a("code",[t._v("Item")]),t._v(" 的高度了。")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("使用 "),a("code",[t._v("getItemLayout")])])]),t._v(" "),a("p",[t._v("前面说了 列表组件在每次 "),a("code",[t._v("Item")]),t._v(" 渲染和滚动复用 "),a("code",[t._v("Item")]),t._v(" 的时候都会通过 "),a("code",[t._v("getItemLayout")]),t._v(" 计算返回offset，在优化初期，我也是直接在 getItemLayout 中传入了一个函数计算高度，后来发现，如果数据量比较大的话，每一个item都要计算，而且item的index 又是累加的话，那么计算的工作量就重复非常多，这个复杂度就是 O(n^2) ，使用的时候完全吃不消。 "),a("code",[t._v("getItemLayout")]),t._v(" 只是要求你返回 "),a("code",[t._v("offset")]),t._v(" "),a("code",[t._v("length")]),t._v(" 和 "),a("code",[t._v("index")]),t._v("， 没有管你怎么计算怎么获取的，所以在 "),a("code",[t._v("redux")]),t._v(" 数据变化时，我们可以获取 · 数据， 根据之前获取的 "),a("code",[t._v("item")]),t._v(" 行数，可以提前计算出每一个 "),a("code",[t._v("index")]),t._v(" 对应的 "),a("code",[t._v("offset")]),t._v(" 和 "),a("code",[t._v("length")]),t._v("，并且直接根据 "),a("code",[t._v("index")]),t._v(" 记录在 数组中。"),a("code",[t._v("getItemLayout")]),t._v(" 直接从数组中取值就行了，现在直接将时间复杂度降低到了 O(1)。")])])}),[],!1,null,null,null);e.default=r.exports}}]);